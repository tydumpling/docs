# 运用前瞻实现密码强度检测

有一个要求，需要设置一个正则检测密码强度，要求有两点：

1. 密码 6-12 位
2. 必须包含数字、大小写字母、特殊字符

咋一看很简单，直接用 `[]` 包含以及 `{6,12}` 设置长度即可，代码如下：

```js
/^[0-9a-zA-Z@!$_]{6,12}$/
```

但是这并不是正确的写法，如果这么写，全是数字的密码也能通过校验。因为上方规则表示任选其一。

想要实现要求，需要使用到前瞻运算。正则匹配实际上是规则和字符串一起移动来匹配，如下：

```js
/^abc$/

abc
```

首先匹配正则的开始标识 `^` ，字符串的匹配指针为字母 `a` 前面；然后正则往后一位匹配到 `a` ，字符串匹配指针也往后一位到字母 `a` ；正则往后一位到 `b` ，字符串匹配指针也往后一位到字母 `b` ......直到最后匹配完毕。

但如果把匹配规则改一下，使用前瞻（也就是正向预查）就无法匹配了。代码如下：

```js
/^(?=a)bc$/

abc
```

正则匹配到前瞻时不会消耗字符，首先匹配正则的开始标识 `^` ，字符串的匹配指针为字母 `a` 前面；然后正则往后一位匹配到前瞻 `(?=a)` ，而字符串的匹配指针不会跟着往后移动。因此匹配不成功。

那他有什么好处呢？可以在匹配的时候先不着急消耗字符串往后匹配，而是先往后看看是否满足规则。用上方的要求来说，利用前瞻不消耗的特性在最开始看后续有没有大小写字母、数字、特殊字符。

修改后写法如下：

```js
/^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@!$_])]{6,12}$/
```

现在就能够实现密码强度检测了。